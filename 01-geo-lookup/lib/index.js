// Generated by CoffeeScript 1.8.0
(function() {
  var GEO_FIELD_COUNTRY, GEO_FIELD_MAX, GEO_FIELD_MIN, fs, gindex, normalize;

  fs = require('fs');

  GEO_FIELD_MIN = 0;

  GEO_FIELD_MAX = 1;

  GEO_FIELD_COUNTRY = 2;

  exports.ip2long = function(ip) {
    ip = ip.split('.', 4);
    return +ip[0] * 16777216 + +ip[1] * 65536 + +ip[2] * 256 + +ip[3];
  };

  gindex = [];

  exports.load = function() {
    var data, line, _i, _len, _results;
    data = fs.readFileSync("" + __dirname + "/../data/geo.txt", 'utf8');
    data = data.toString().split('\n');
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      line = data[_i];
      if (!(line)) {
        continue;
      }
      line = line.split('\t');
      gindex.push([+line[0], +line[1], line[3]]);
    }
    // sort the gindex ascending
    return gindex.sort(function (a,b) {
      return a[0] - b[0];
    });
  };

  normalize = function(row) {
    return {
      country: row[GEO_FIELD_COUNTRY]
    };
  };

  exports.lookup = function(ip) {
    var find, line, left, middle, right;
    if (!ip) {
      return -1;
    }
    find = this.ip2long(ip);
    left = 0;
    right = gindex.length - 1;

    while(left <= right){
      // Start counting from the middle since it will be the shortest distance
      middle = parseInt((left + right)/2);
      line = gindex[middle];
      if (find >= line[GEO_FIELD_MIN] && find <= line[GEO_FIELD_MAX]) {
        return normalize(line);
      }
      // if find is less than line[GEO_FIELD_MIN]
      // set right to equal the midlle minus 1
      // this eliminates half of the index and exponentially increasing the look up speed
      else if (find < line[GEO_FIELD_MIN]) {
        right = middle - 1;
      }
      // elimate the left side and srink the search again
      else {
        left = middle + 1;
      }
    }
    return null;
  };

}).call(this);
